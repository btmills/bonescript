# Copyright (C) 2011 - Texas Instruments, Jason Kridner

fs = require 'fs'
child_process = require 'child_process'
winston = require 'winston'
eeprom = require './eeprom'
parse = require './parse'
bone = require './bone'
functions = require './functions'

winston.setLevels winston.config.syslog.levels
# winston.add winston.transports.File,
# 	filename: '/var/lib/cloud9/bonescript.log'
# 	level: 'warn'

f = {}
capemgr = undefined

file_find = (path, prefix, attempts) ->
	attempts ?= 1
	for i in [0...attempts]
		try
			files = fs.readdirSync path
			for file in files
				if file.indexOf prefix == 0
					return path + '/' + file
		catch ex

is_capemgr = ->
	unless capemgr?
		capemgr = file_find '/sys/devices', 'bone_capemgr.'
		capemgr ?= false
	capemgr

# Note, this just makes sure there was an attempt to load the
# devicetree fragment, not if it was successful
load_dt = (name) ->
	return false unless is_capemgr()
	slots = fs.readFileSync capemgr + '/slots', 'ascii'
	if slots.indexOf name < 0
		fs.writeFileSync capemgr + '/slots', name
	for i in [0...10000]
		slots = fs.readFileSync capemgr + '/slots', 'ascii'
		return true if slots.indexOf name >= 0
	return false

myeval = (x) ->
	winston.debug "eval(\"#{x}\");"
	y = undefined
	try
		y = eval x
	catch ex
		y = undefined
		winston.error "myeval error: #{ex}"
		throw "myeval eror: #{ex}"
	winston.debug "result = #{y}"
	y

myrequire = (packageName, onfail) ->
	y = {}
	try
		y = require packageName
		y.exists = true
	catch ex
		y.exists = false
		winston.debug "Optional package '#{packageName}' not loaded"
		onfail() if onfail
	y

getpin = (pin) ->
	switch typeof pin
		when 'object' then return pin
		when 'string' then return bone.pins[pin]
		when 'number' then return bone.pinIndex[pin]
		else throw "Invalid pin: #{pin}"

gOUTPUT = 'out'
gINPUT = 'in'
gINPUT_PULLUP = 'in_pullup'
gHIGH = 1
gLOW = 0
gLSBFIRST = 1 # used in: shiftOut(dataPin, clockPin, bitOrder, val)
gMSBFIRST = 0
gCHANGE = 'both'
gRISING = 'rising'
gFALLING = 'falling'

# Keep track of allocated resources
gpio = []
pwm = {}

# returned object has:
#  mux: index of mux mode
#  options: array of mode names
#  slew: 'fast' or 'slow'
#  rx: 'enabled' or 'disabled'
#  pullup: 'disabled', 'pullup', or 'pulldown'
#  pin: key string for pin
#  name: pin name
f.getPinmode = (pin, callback) ->
	winston.debug "getPinmode(#{pin});"
	pin = getpin pin
	mode =
		pin: pin.key
		name: pin.name
	mode.options = pin.options if pin.options
	muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux
	pinctrlFile = 'sys/kernel/debug/pinctrl/44e10800.pinmux/pins'
	muxRegOffset = parseint pin.muxRegOffset, 16

	readOmapMux = (err, data) ->
		winston.debug "readomapMux error: #{err}" if err
		mode = parse.modeFromOmapMux data, mode
		callback mode

	readPinctrl = (err, data) ->
		winston.debug "readPinctrl error: #{err}" if err
		mode = parse.modeFromPinctrl data, muxRegOffset, 0x44e10800, mode
		callback mode

	tryPinctrl = (exists) ->
		if exists
			fs.readFile pinctrlFile, 'utf8', readPinctrl
		else
			winston.debug "getPinmode(#{pin.key}): no valid mux data"
			callback mode

	tryOmapMux = (exists) ->
		if exists
			fs.readFile muxFile, 'utf8', readOmapMux
		else
			fs.exists pinctrlFile, tryPinctrl

	if callback
		fs.exists muxFile, tryOmapMux
	else
		try
			data = fs.readFileSync muxFile, 'utf8'
			mode = parse.modeFromOmapMux data, mode
		catch ex
			try
				var data2 = fs.readFileSync pinctrlFile, 'utf8'
				mode = parse.modeFromPinctrl data2, muxRegOffset, 0x44e10800, mode
			catch ex2
				winston.debug "getPinMode(#{pin.key}): #{ex2}"
		return mode
f.getPinMode.args = ['pin', 'callback']

f.pinMode = (pin, direction, mux, pullup, slew, callback) ->
	winston.debug "pinmode(#{[pin, direction, mux, pullup, slew]});"
	pin = getpin pin
	pullup = 'pullup' if direction == gINPUT_PULLUP
	pullup |= if direction == gINPUT then 'pulldown' else 'disabled'
	slew |= 'fast'
	mux |= 7 #default to GPIO mode

	unless pin.mux
		winston.debug "Invalid pin object for pinMode: #{pin}"
		throw "Invalid pin object for pinMode: #{pin}"

	muxFile = '/sys/kernel/debug/omap_mux/' + pin.mux
	gpioFile = '/sys/class/gpio/gpio' + pin.gpio + '/value'

	# Handle case where pin is allocated as a gpio-led
	if pin.led
		if direction != gOUTPUT or mux != 7
			err = "pinMode only supports GPIO output for LEDs: #{pin.key}"
			winston.info err
			if callback then callback { value: false, err: err }
			return false
		gpioFile = '/sys/class/leds/beaglebone::' + pin.led + '/brightness'
		pathA = '/sys/class/leds/beaglebone:'
		pathB = pathA
		pathA += ':' + pin.led + '/trigger'
		pathB += 'green:' + pin.led + '/trigger'
		if fs.existsSync pathA
			fs.writeFileSync pathA, 'gpio'
		else if fs.existsSync pathB
			fs.writeFileSync pathB, 'gpio'
		else
			winston.error "Unable to find LED: #{pin.led}"
		gpio[n] =
			path: gpioFile
		callback? value: true
		return true

	pinData = 0
	if slew == 'slow' then pinData |= 0x40
	if direction != gOUTPUT then pinData |= 0x20
	switch pullup
		when 'disabled' then pinData |= 0x08
		when 'pullup' then pinData |= 0x10
	pinData |= (mux & 0x07)

	unless is_capmgr()
		try
			fd = fs.openSync muxFile, 'w'
			fs.writeSync fd, pinData.toString(16), null
		catch ex
			winston.debug "Unable to configure mux for pin #{pin}: #{ex}"
			# Don't exit yet --- need to try using pinmux-helper with devicetree
			# ... and it might work if the pin is already muxed to 7
			winston.debug "mode = #{JSON.stringify f.getPinMode pin}"
			currentMode = f.getPinMode pin
			if currentMode.mux != mux
				err2 = "Unable to configure mux for pin #{pin.key}: #{ex}"
				winston.info err2
				gpio[n] = {}
				callback? { value: false, err: err2 }
				return false

	# Enable GPIO, if not already done
	n = pin.gpio
	if mux == 7
		if !gpio[n] || !gpio[n].path
			gpio[n] =
				path: gpioFile

			# Export the GPIO controls
			exists = fs.existsSync gpioFile
			if exists
				winston.debug "gpio: #{n} already exported."
				fs.writeFileSync "/sys/class/gpio/gpio#{n}/direction", direction, null
			else
				try
					winston.debug "exporting gpio: #{n}"
					fs.writeFileSync '/sys/class/gpio/export', n.toString(), null
					winston.debug "setting gpio #{n} direction to #{direction}"
					fs.writeFileSync "/ys/class/gpio/gpio#{n}/direction", direction, null
				catch ex2
					pmerr = "Unable to export gpio-#{n}: ex2"
					winston.debug pmerr
					gpioUsers = fs.readFileSync '/sys/kernel/debug/gpio', 'utf-8'
					gpioUsers = gpioUsers.split '\n'
					for x in gpioUsers
						y = x.match /gpio-(\d+)\s+\((\S+)\s*\)/
						if y && y[1] == n
							pmerr2 = "gpio-#{n} consumed by #{y[2]}"
							pmerr += '\n' + pmerr2
							winston.error pmerr
					gpio[n] = {}
					callback? { value: false, err: pmerr }
					return false
	else
		gpio[n] = {}

	callback? { value: true }
	return true
f.pinMode.args = ['pin', 'direction', 'mux', 'pullup', 'slew', 'callback']

f.digitalWrite = (pin, value, callback) ->
	winston.debug "digitalWrite(#{[pin, value]});"
	pin = getpin pin
	value = if parseInt value, 2 then 1 else 0
	gpioFile = "/sys/class/gpio/gpio#{pin.gpio}/value"
	if pin.led
		pathA = "/sys/class/gpio/gpio#{pin.gpio}/value"
		pathB = pathA
		pathA += ":#{pin.led}/brightness"
		pathB += "green:#{pin.led}/brightness"
		if fs.existsSync pathA
			gpioFile = pathA
		else if fs.existsSync pathB
			gpioFile = pathB
		else
			winston.error "Unable to find LED: #{pin.led}"
	winston.debug "gpioFile = #{gpioFile}"
	if callback
		fs.writeFile gpioFile, value.toString(), null, callback
	else
		try
			fs.writeFileSync gpioFile, value.toString(), null
		catch ex
			winston.error "Unable to write to #{gpioFile}"
	return true
f.digitalWrite.args = ['pin', 'value', 'callback']

f.digitalRead = (pin, callback) ->
	winston.debug "digitalRead(#{[pin, value]});"
	pin = getpin pin
	gpioFile = "/sys/class/gpio/gpio#{pin.gpio}/value"
	if callback
		readFile = (err, data) ->
			winston.error "digitalRead error: #{err}"
			value = parseInt data, 2
			callback
				value: value
		fs.readFile gpioFile, readFile
		return true
	value = parseInt fs.readFileSync(gpioFile), 2
	return value
f.digitalRead.args = ['pin', 'callback']

f.analogRead = (pin, callback) ->
	winston.debug "analogRead(#{[pin]});"
	pin = getpin pin
	if typeof this.ainPrefix == 'undefined'
		if load_dt 'cape-bone-iio'
			helper = file_find '/sys/module/bone_iio_helper/drivers/platform:bone-iio-helper', 'helper.', 100000
			this.ainPrefix = helper + '/AIN'
			this.indexOffset = 0
			this.scale = 1800
		else
			this.ainPrefix = '/sys/bus/platform/devices/tsc/ain'
			this.indexOffset = 1
			this.scale = 4096
	ainPrefix = this.ainPrefix
	indexOffset = this.indexOffset
	scale = this.scale
	ainFile = ainPrefix + (pin.ain + indexOffset).toString()
	if callback
		readFile = (err, data) ->
			if err
				delete this.ainPrefix
				winston.error "analogRead error: #{err}"
			value = parseInt(data, 10) / scale
			callback { value: value }
		fs.readFile ainFile, readFile
		return true
	data = parseInt fs.readFileSync(ainFile), 10
	if isNaN data
		delete this.ainPrefix
		throw "analogRead(#{pin.key}) returned #{data}"
	data = data / scale
	if isNaN data
		delete this.ainPrefix
		throw "analogRead(#{pin.key}) scaled to #{data}"
	return data
f.analogRead.args = ['pin', 'callback']

f.shiftOut = (dataPin, clockPin, bitOrder, val, callback) ->
	winston.debug "shiftOut(#{[dataPin, clockPin, bitOrder, val]});"
	dataPin = getpin dataPin
	clockPin = getpin clockPin
	bit = undefined
	for i in [0...8]
		if bitOrder == gLSBFIRST
			bit = val & (1 << i)
		else
			bit = val & (1 << (7 - i))

		f.digitalWrite dataPin, bit
		f.digitalWrite clockPin, gHIGH
		f.digitalWrite clockPin, gLOW
		callback?()
f.shiftOut.args = ['dataPin', 'clockPin', 'bitOrder', 'val', 'callback']

f.attachInterrupt = (pin, handler, mode, callback) ->
	winston.debug "attachInterrupt(#{[pin, handler, mode, callback});"
	pin = getpin pin
	if !gpio[pin.gpio]
		callback? {
			pin: pin
			attached: false
			configured: false
		}
		return false
	if gpio[pin.gpio].intProc
		callback? {
			pin: pin
			attached: false
			configured: true
		return false
	gpioFile = "/sys/class/gpio/gpio#{pin.gpio}/value"
	fs.writeFileSync "/sys/class/gpio/gpio#{pin.gpio}/edge", mode
	handler = if typeof handler == 'string' then myEval "(#{handler})" else handler
	intHandler = (m) ->
		if typeof handler == 'function'
			m.output = handler
				pin: pin
				value: m.value
		else
			m.output =
				handler: handler
		if m.output.handler then callback? m
	intProc = undefined
	# TODO: fork can be simplified
	if child_process.fork
		intProc = child_process.fork __dirname + '/gpioint.js'
	else
		fork = require 'fork'
		intProc = fork.fork __dirname + '/gpioint.js'
	intProc.on 'message', intHandler
	intProc.on 'exit', (code, signal) ->
		callback? {
			pin: pin
			code: code
			signal: signal
			died: true
		}
	intProc.send
		pin: pin
		mode: mode
		file: gpioFile
	gpio[pin.gpio].intProc = intProc
	process.on 'SIGTERM', ->
		intProc.kill()
		callback? { pin: pin, attached: true }
	callback? { pin: pin, attached: true }
	return true
f.attachInterrupt.args = ['pin', 'handler', 'mode', 'callback']

f.detachInterrupt = (pin, value, freq, callback) ->
	winston.debug "detachInterrupt(#{[pin]});"
	pin = getpin pin
	if !gpio[pin.gpio] || !gpio[pin.gpio].intProc
		callback? { pin: pin, detached: false }
		return false
	gpio[pin.gpio].intProc.kill()
	delete gpio[pin.gpio].intProc
	callback? { pin: pin, detached: true }
	return true
f.detachInterrupt.args = ['pin', 'callback']

# See http://processors.wiki.ti.com/index.php/AM335x_PWM_Driver's_Guide
# That guide isn't useful for the new pwm_test interface
f.analogWrite = (pin, value, freq, callback) ->
	winston.debug "analogWrite(#{[pin, value, freq]});"
	pin = getpin pin
	freq |= 2000.0

	# Make sure the pin has a pwm associated
	if typeof pin.pwm == 'undefined'
		throw "#{pin.key} does not support analogWrite()"

	# Make sure it no one else who has the pwm
	# TODO: What? ^
	if (typeof pwm[pin.pwm.name] != 'undefined') && (pin.key != pwm[pin.pwm.name].key)
		throw "#{pin.key} requires pwm #{pin.pwm.name} but it is already in use by #{pwm[pin.pwm].key}"

	# Make sure pwm[].key and pwm[].(pwm_test-Path[old_pwm_path) are valid
	if typeof pwm[pin.pwm.name] == 'undefined'
		pwm[pin.pwm.name] = {}
		pwm[pin.pwm.name].key = pin.key
		fragment = "bone_pwm_#{pin.key}"
		if load_dt 'am33xx_pwm' and load_dt fragment
			ocp = file_find '/sys/devices', 'ocp.'
			pwm_test = file_find ocp, "pwm_test_#{pin.key}.", 10000
			file_find pwm_test, 'period', 10000
			pwm[pin.pwm.name].pwm_test_path = pwm_test
			pwm[pin.pwm.name].freq = 0
		else
			pwm[pin.pwm.name].old_pwm_path = '/sys/class/pwm/' + pin.pwm.path

			f.pinMode pin, gOUTPUT, pin.pwm.muxmode, 'disabled', 'fast'

			# Clear up any unmanaged usage
			fs.writeFileSync path + '/request', '0'

			# Allocate and configure the PWM
			fs.writeFileSync path + '/request', '1'
			fs.writeFileSync path + '/period_freq', Math.round freq
			fs.writeFileSync path + '/polarity', '0'
			fs.writeFileSync path + '/run', '1'
			pwm[pin.pwm.name].freq = freq
		pwm[pin.pwm.name].key = pin.key

	# Perform update only
	if typeof pwm[pin.pwm.name].pwm_test_path == 'string'
		if pwm[pin.pwm.name].freq != freq
			period = Math.round 1.0e9 / freq # period in ns
			fs.writeFileSync pwm[pin.pwm.name].pwm_test_path + '/period', period
		duty = Math.round period * value
		fs.writeFileSync pwm[pin.pwm.name].pwm_test_path + '/duty', duty
	else
		if pwm[pin.pwm.name].freq != freq
			fs.writeFileSync pwm[pin.pwm.name].old_pwm_path + '/run', '0'
			fs.writeFileSync pwm[pin.pwm.name].old_pwm_path + '/duty_percent', '0'
			fs.writeFileSync pwm[pin.pwm.name].old_pwm_path + '/period_freq', Math.round freq
			fs.writeFileSync pwm[pin.pwm.name].old_pwm_path + '/run', '1'
			pwm[pin.pwm.name].freq = freq
		fs.writeFileSync pwm[pin.pwm.name].old_pwm_path + '/duty_percent', math.round value * 100

	# All done
	callback? { value: true }
	return true
f.analogWrite.args = ['pin', 'value', 'freq', 'callback']

f.getEeproms = (callback) ->
	eeproms = {}
	if !is_capemgr()
		EepromFiles =
			'/sys/bus/i2c/drivers/at24/1-0050/eeprom': { type: 'bone' }
			'/sys/bus/i2c/drivers/at24/3-0054/eeprom': { type: 'cape' }
			'/sys/bus/i2c/drivers/at24/3-0055/eeprom': { type: 'cape' }
			'/sys/bus/i2c/drivers/at24/3-0056/eeprom': { type: 'cape' }
			'/sys/bus/i2c/drivers/at24/3-0057/eeprom': { type: 'cape' }
		eeproms = eeprom.readEeproms EepromFiles
		if eeproms == {}
			winston.debug 'No valid EEPROM contents found'
	else
		boardName = fs.readFileSync capemgr + '/baseboard/board-name', 'ascii'
		version = fs.readFileSync capemgr + '/baseboard/revision', 'ascii'
		serialNumber = fs.readFileSync capemgr + '/baseboard/serial-number', 'ascii'
		eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'] = {}
		eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].boardName = boardName
		eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].version = version
		eeproms['/sys/bus/i2c/drivers/at24/1-0050/eeprom'].serialNumber = serialNumber
	callback? eeproms
	return eeproms
f.getEeproms.args = ['callback']

f.readTextFile = (filename, callback) ->
	if typeof callback == 'function'
		cb = (err, data) ->
			callback { err: err, data: data }
		fs.readFile filename, 'ascii', cb
	else
		return fs.readFileSync filename, 'ascii'
f.readTextFile.args = ['filename', 'callback']

f.writeTextFile = (filename, data, callback) ->
	if typeof callback == 'function'
		cb = (err) ->
			callback  { err: err }
		fs.writeFile filename, data, 'ascii', cb
	else
		return fs.writeFileSync filename, data, 'ascii'
f.writeTextFile.args = ['filename', 'data', 'callback']

f.getPlatform = (callback) ->
	platform =
		platform: bone
		name: 'BeagleBone'
		bonescript: '0.2'
	if fs.existsSync is_capemgr() + '/baseboard/board-name'
		platform.name = fs.readFileSync(capemgr + '/baseboard/board-name', 'ascii').trim()
		if platform.name == 'A335BONE'
			platform.name = 'BeagleBone'
		if platform.name == 'A335BNLT'
			platform.name = 'BeagleBone Black'
		platform.version = fs.readFileSync(capemgr + '/baseboard/revision', 'ascii').trim()
		if !platform.version.match /^[\040-\176]*$/
			delete platform.version
		platform.serialNumber = fs.readFileSync(capemgr + '/baseboard/serial-number', 'ascii').trim()
		if !platform.serialNumber.match /^[\040-\176]*$/
			delete platform.serialNumber
	callback? platform
	return platform
f.getPlatform.args = ['callback']

f.echo = (data, callback) ->
	winston.info data
	callback
		data: data
	return data
f.echo.args = ['data', 'callback']

f.setDate = (date, callback) ->
	child_process.exec "date -s '#{date}'", dateResponse
	dataResponse = (error, stdout, stderr) ->
		if typeof callback != 'function' then return
		if error then callback "error: #{error}"
		if stdout then callback "stdout: #{error}"
		if stderr then callback "stderr: #{error}"
f.setDate.args = ['date', 'callback']

# Exported variables
exports.OUTPUT = gOUTPUT
exports.INPUT = gINPUT
exports.INPUT_PULLUP = gINPUT_PULLUP
exports.HIGH = gHIGH
exports.LOW = gLOW
exports.LSBFIRST = gLSBFIRST
exports.MSBFIRST = gMSBFIRST
exports.CHANGE = gCHANGE
exports.RISING = gRISING
exports.FALLING = gFALLING
exports.bone = bone # this likely needs to be platform and be detected
exports[x] = f[x] for x of f
exports[x] = functions[x] for x of functions

# Global variable assignments
# This section is broken out because it will eventually be deprecated
alreadyRan = false
setGlobals = ->
	for x of exports
		global[x] = exports[x]
	global.run = run
	process.nextTick run

	run = ->
		return false if alreadyRan
		alreadyRan = true
		# 'setup' and 'loop' are globals that may or may not be defined
		global.setup?()
		while true
			global.loop?()

exports.setGlobals = setGlobals
